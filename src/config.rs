use dirs;
use serde::{Deserialize, Serialize};
use std::{fs, path::PathBuf};

use crate::types::Peer;
use crate::types::WatchedFolder;

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("Failed to read file {path:?}")]
    ReadError {
        path: std::path::PathBuf,
        #[source]
        source: std::io::Error,
    },
    #[error("Failed to store file {path:?}")]
    WriteError {
        path: std::path::PathBuf,
        #[source]
        source: std::io::Error,
    },
    #[error("No config directory found.")]
    NoConfigDir,
    #[error(transparent)]
    ParseError(#[from] toml::de::Error),
    #[error(transparent)]
    SerializeError(#[from] toml::ser::Error),
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Config {
    paths: Vec<WatchedFolder>,
    peers: Vec<Peer>,
}

impl Config {
    /// Loads the configuration from disk.
    /// If none exists, creates the default one
    pub fn get() -> Result<Self, Error> {
        match Self::load() {
            Ok(config) => {
                log::info!("Using existing config.");
                Ok(config)
            }
            Err(e) => match e {
                Error::ReadError {
                    path: _,
                    ref source,
                } => {
                    if source.kind() == std::io::ErrorKind::NotFound {
                        Self::create_default()
                    } else {
                        Err(e)
                    }
                }
                _ => Err(e),
            },
        }
    }

    /// Loads a configuration file from disk.
    fn load() -> Result<Self, Error> {
        let path = Self::config_path()?;
        let config =
            fs::read_to_string(&path).map_err(|source| Error::ReadError { path, source })?;
        toml::from_str(&config).map_err(Error::from)
    }

    fn store(&self) -> Result<(), Error> {
        let path = Self::config_path()?;

        // TODO maybe handle unwrap here
        fs::create_dir_all(&path.parent().unwrap()).map_err(|source| Error::WriteError {
            path: path.clone(),
            source,
        })?;
        let content = toml::to_string_pretty(self).map_err(Error::from)?;
        let content = format!(
            "# File automaticaly generated by p2p_file_sync
# Do not edit manually, unless you know what you are doing!\n\n{}",
            content
        );
        fs::write(&path, content).map_err(|source| Error::WriteError { path, source })?;
        Ok(())
    }

    /// Creates a default config, stores it and returns it
    /// TODO this currently just overrides existing configs
    fn create_default() -> Result<Self, Error> {
        log::info!("Creating default config...");
        let mut paths: Vec<WatchedFolder> = vec![];
        if let Some(docs) = dirs::document_dir() {
            paths.push(WatchedFolder::new(docs));
        };

        let config = Config {
            paths,
            peers: vec![],
        };

        config.store()?;

        Ok(config)
    }

    fn config_path() -> Result<PathBuf, Error> {
        if let Some(config_path) = dirs::config_dir() {
            Ok(config_path.join("p2p").join("config.toml"))
        } else {
            Err(Error::NoConfigDir)
        }
    }
}
